(()=>{"use strict";var e={};(e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})})(e);const{Worker:r}=require("worker_threads"),o=require("fs"),t=require("path"),n=require("yargs").option("input",{type:"string",demandOption:!0}).option("output",{type:"string",demandOption:!0}).help().argv,s=o.readFileSync(t.join(__dirname,"src/image-target/compiler.worker.js"),"utf8");var a,i;(a=n.input,i=n.output,new Promise((e,o)=>{const t=new r(`\n      const { parentPort, workerData } = require('worker_threads');\n      const path = require('path');\n      const fs = require('fs');\n\n      const workerCode = \`${s}\`;\n      const fakeModule = { exports: {} };\n      const fakeRequire = (id) => {\n        if (id.startsWith('@tensorflow')) return require('@tensorflow/tfjs-node');\n        return require(id);\n      };\n\n      try {\n        const compile = new Function('module', 'exports', 'require', workerCode + '\\nreturn compile;')(fakeModule, fakeModule.exports, fakeRequire);\n        compile(workerData.input, workerData.output)\n          .then(() => parentPort.postMessage({ success: true }))\n          .catch(err => parentPort.postMessage({ success: false, error: err.message }));\n      } catch (err) {\n        parentPort.postMessage({ success: false, error: err.message });\n      }\n    `,{eval:!0,workerData:{input:a,output:i}});t.on("message",r=>{r.success?e():o(new Error(r.error))}),t.on("error",o),t.on("exit",e=>{0!==e&&o(new Error(`Worker stopped with exit code ${e}`))})})).then(()=>console.log("Compilation successful:",n.output)).catch(e=>{console.error("Compilation failed:",e.message),process.exit(1)}),module.exports=e})();